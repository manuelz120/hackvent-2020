# HV20.12 Wiener waltz

For this challenge, we get a PCAP file that contains RSA encrypted communication. We know that the encryption was done using a custom implementation of RSA using a large private exponent to save computing power. As in most cases, implementing your own crypto is a bad idea. In this particular case, it could lead to the encryption being vulnerable against the [Wiener Attack](https://en.wikipedia.org/wiki/Wiener%27s_attack). 

The first step to exploit this vulnerability and decrypt the traffic is exporting the public keys for the encryption. As the communication was done using a custom implementation of the protocol, I had to dig through the PCAP file. After a while, I finally found the needed parameter which were sent as JSON payload:

```json
{
  "pubkey": {
    "n": "dbn25TSjDhUge4L68AYooIqwo0HC2mIYxK/ICnc+8/0fZi1CHo/QwiPCcHM94jYdfj3PIQFTri9j/za3oO+3gVK39bj2O9OekGPG2M1GtN0Sp+ltellLl1oV+TBpgGyDt8vcCAR1B6shOJbjPAFqL8iTaW1C4KyGDVQhQrfkXtAdYv3ZaHcV8tC4ztgA4euP9o1q+kZux0fTv31kJSE7K1iJDpGfy1HiJ5gOX5T9fEyzSR0kA3sk3a35qTuUU1OWkH5MqysLVKZXiGcStNErlaggvJb6oKkx1dr9nYbqFxaQHev0EFX4EVfPqQzEzesa9ZAZTtxbwgcV9ZmTp25MZg==",
    "e": "S/0OzzzDRdsps+I85tNi4d1i3d0Eu8pimcP5SBaqTeBzcADturDYHk1QuoqdTtwX9XY1Wii6AnySpEQ9eUEETYQkTRpq9rBggIkmuFnLygujFT+SI3Z+HLDfMWlBxaPW3Exo5Yqqrzdx4Zze1dqFNC5jJRVEJByd7c6+wqiTnS4dR77mnFaPHt/9IuMhigVisptxPLJ+g9QX4ZJX8ucU6GPSVzzTmwlDIjaenh7L0bC1Uq/euTDUJjzNWnMpHLHnSz2vgxLg4Ztwi91dOpO7KjvdZQ7++nlHRE6zlMHTsnPFSwLwG1ZxnGVdFnuMjEbPA3dcTe54LxOSb2cvZKDZqA==",
    "format": ["mpz_export", -1, 4, 1, 0]
  },
  "sessionId": "RmERqOnbsA/oua67sID4Eg=="
}
```

Moreover, I was able to extract 4 blocks of the encrypted message (see `blocks/[0-4].json`).


Unfortunately, the parameters of the public key are not just base64 encoded, but binary data generated by a `mpz_export`. The parameters for the export are all listed in the `format` parameter of the JSON file. Using the `mpz_import` (see https://gmplib.org/manual/Integer-Import-and-Export) function of GMP, I was able to get the final parameters for the public key (implementation can be found in [decode-parameters.c](./decode-parameters.c)).

```
n = 21136187113648735910956792902340987261238482724808044660872655926597365083148384784275999147719115005171023510870084682239018605609844594894880405609510814634404536868649155403129057903532257019060842686994634155205978467383309519881921823354273590936861045431841523283059891729069450531823193829758198452195159839001802409808310303539270828581792136817589972743921904535921749280330153901291531642543946250472645757855636930605097838505480384294629089321241798555566459046743741824235125746402090921912493396059817338067723079903962753795145687173236901003277653830701564333638891277876961702941978996729372105897701
e = 12703148700486856571456640284543930158485441147798980218669328932721873837903118006895885638306703700146300157588744922573525972231890883171794381140159146432366116691422353585619938803060563166160513071142031888780581428871210353376077782114636012547145421154246397069298658668372048637974096728556378192041823865600245728866360820303463508288677034505462614941425772365440025016354622878586568634346248386264921756141627262617888108166058845769396410463089005177762158324354462305559557728141729110983431022424786938837309186823930758907423061347118761390982013522713098779662020937499191572512966979990705904881359
```

Now we can simply use the `Wiener Attack` implementation of the almighty [RSACtfTool](https://github.com/Ganapati/RsaCtfTool) to generate the [private RSA key](./private.key). The tool also allows us to simply decrypt the blocks. However, it took me quite a while to figure out that all blocks have to be decrypted together, not separately. Still, after a while I finally managed to do so and got a valid flag:

**Flag:** HV20{5hor7_Priv3xp_a1n7_n0_5mar7}